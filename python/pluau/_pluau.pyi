# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import typing
from enum import Enum

class Buffer:
    ...

class Compiler:
    r"""
    Represents a Luau compiler that compiles Luau chunks into bytecode.
    
    Note: All pluau `Lua` instances have a default compiler set to compile Lua chunks.
    However you can create your own compiler with custom settings using this class.
    """
    def __new__(cls, optimization_level:builtins.int, debug_level:builtins.int, type_info_level:builtins.int, coverage_level:builtins.int) -> Compiler:
        r"""
        Constructs a new Compiler with the specified settings.
        
        # Arguments:
        - `optimization_level`: The optimization level for the Lua chunk (0 = no optimization, 1 = basic optimization, 2 = full optimization which may impact debugging).
        - `debug_level`: The debug level for the Lua chunk (0 = no debugging, 1 = line info + function names only, 2 = full debug info with locals+upvalues)
        - `type_info` (0 = native modules only, 1 = all modules)
        """
    def compile(self, source:builtins.str) -> builtins.list[builtins.int]:
        r"""
        Compiles a Lua source code string into bytecode.
        """

class Function:
    @property
    def pointer(self) -> builtins.int:
        r"""
        Returns the pointer to the Lua function value.
        
        This pointer cannot be converted back to a Lua function
        and is only useful for hashing and debugging.
        """
    def call(self, args:typing.Sequence[None | builtins.bool | LightUserData | builtins.int | builtins.float | Vector | builtins.str | String | Table | Function | Thread | UserData | Buffer]) -> builtins.list[None | builtins.bool | LightUserData | builtins.int | builtins.float | Vector | builtins.str | String | Table | Function | Thread | UserData | Buffer]:
        r"""
        Calls the Lua function with the provided arguments.
        """
    def deep_clone(self) -> Function:
        r"""
        Returns a deep clone to a Lua-owned function
        
        If called on a Luau function, this method copies the function prototype and all its upvalues to the newly created function
        
        If called on a Python function, this method merely clones the function's handle
        """
    def environment(self) -> typing.Optional[Table]:
        r"""
        Returns the environment table of the Lua function
        
        Returns None if the function does not have an environment
        
        Python functions do not have an environment, so this will always return None
        """
    def set_environment(self, table:Table) -> None:
        r"""
        Sets the environment table of the Lua function
        
        This uses setfenv and will hence deoptimize your function. Consider using load_chunk's environment argument instead
        """
    def __eq__(self, other:Function) -> builtins.bool: ...
    def __repr__(self) -> builtins.str: ...

class LightUserData:
    @property
    def pointer(self) -> builtins.int:
        r"""
        Returns the pointer/address of the light userdata.
        """

class Lua:
    r"""
    Represents a Luau VM handle
    """
    def __new__(cls, stdlib:typing.Optional[builtins.int]=None) -> Lua:
        r"""
        Constructs a new Lua VM with an optional standard library set
        """
    def __repr__(self) -> builtins.str: ...
    def used_memory(self) -> builtins.int:
        r"""
        Returns the amount of memory used by the Lua VM
        """
    def memory_limit(self) -> builtins.int:
        r"""
        Returns the memory limit of the Lua VM
        """
    def set_memory_limit(self, limit:builtins.int) -> None:
        r"""
        Sets the memory limit for the Lua VM.
        """
    def sandbox(self, enabled:builtins.bool) -> None:
        r"""
        Enables or disables the sandbox mode for the Luau VM.
        
        This method, in particular:
        
        - Set all libraries to read-only
        - Set all builtin metatables to read-only
        - Set globals to read-only (and activates safeenv)
        - Setup local environment table that performs writes locally and proxies reads to the global environment.
        - Allow only count mode in collectgarbage function.
        
        Note that this is a Luau-specific feature.
        """
    def set_compiler(self, compiler:Compiler) -> None:
        r"""
        Sets the compiler to use
        """
    def create_string(self, value:String | builtins.str | bytes) -> String:
        r"""
        Creates a new Lua string
        """
    def create_function(self, callback:typing.Any) -> Function:
        r"""
        Creates a new Lua function
        """
    def current_thread(self) -> Thread:
        r"""
        Returns a handle to the active Thread.
        
        When using a Lua handle originating outside a callback. this will be the main Lua thread
        
        Within a callback, this will return a reference to the Lua thread that called the callback.
        """
    def set_type_metatable(self, type_:LuaType, metatable:typing.Optional[Table]) -> None:
        r"""
        Sets the metatable for a type
        
        # Arguments
        - `type`: The type to set the metatable for
        - `metatable`: The metatable to set
        """
    def set_registry_value(self, key:builtins.str, value:None | builtins.bool | LightUserData | builtins.int | builtins.float | Vector | builtins.str | String | Table | Function | Thread | UserData | Buffer) -> None:
        r"""
        Sets a value on the Lua registry with a given key name
        """
    def get_registry_value(self, key:builtins.str) -> None | builtins.bool | LightUserData | builtins.int | builtins.float | Vector | builtins.str | String | Table | Function | Thread | UserData | Buffer:
        r"""
        Gets a value from the Lua registry by key name
        """
    def globals(self) -> Table:
        r"""
        Returns the global environment table of the Lua VM
        """
    def set_globals(self, table:Table) -> None:
        r"""
        Sets the global environment table of the Lua VM
        Note that any existing Lua functions have cached global environment and will not see the changes made by this method.
        
        To update the environment for existing Lua functions, use Function.set_environment instead.
        """
    def set_interrupt(self, callback:typing.Any) -> None:
        r"""
        Sets an interrupt function that will periodically be called by Luau VM. The interrupt function will provide the callback VM as arguments and expects a VmState to be returned.
        
        Any Luau code is guaranteed to call this handler “eventually” (in practice this can happen at any function call or at any loop iteration).
        
        The provided interrupt function can error, and this error will be propagated through the Luau code that was executing at the time the interrupt was triggered.
        
        Also this can be used to implement continuous execution limits by instructing Luau VM to yield by returning VmState.Yield.
        """
    def remove_interrupt(self) -> None:
        r"""
        Removes the currently set interrupt function
        
        This is a no-op if no interrupt function was set.
        """
    def load_chunk(self, contents:String | builtins.str | bytes, name:typing.Optional[builtins.str]=None, env:typing.Optional[Table]=None, is_binary_chunk:typing.Optional[builtins.bool]=None, compiler:typing.Optional[Compiler]=None) -> Function:
        r"""
        Loads a luau chunk into a function
        """
    def create_table(self) -> Table:
        r"""
        Creates a table
        """
    def create_table_with_capacity(self, narr:builtins.int, nrec:builtins.int) -> Table:
        r"""
        Creates a table with `narr` being the capacity of the array part and `nrec` being the capacity of the hash part.
        """
    def create_thread(self, func:Function) -> Thread:
        r"""
        Creates a new Lua thread given its base Lua function
        
        Equivalent to ``coroutine.create(func)`` in Luau
        """
    def create_buffer(self, contents:String | builtins.str | bytes) -> Buffer:
        r"""
        Creates a new Luau buffer
        """
    def create_userdata(self, data:typing.Any, metatable:Table) -> UserData:
        r"""
        Creates a new Userdata given associated data and a metatable
        """
    def yield_with(self, values:typing.Sequence[None | builtins.bool | LightUserData | builtins.int | builtins.float | Vector | builtins.str | String | Table | Function | Thread | UserData | Buffer]) -> None:
        r"""
        Tells Lua to the currently running Lua thread once the ongoing callback returns.
        
        Any results from the ongoing callback will be ignored and the args passed to yield_with will instead be yielded
        """

class RawError(builtins.BaseException):
    r"""
    A special error type in which only the message is sent as a error to Luau
    
    Other error types will include the type name and the message, but this error will only include the message.
    
    Raising a ValueError for example will lead to `ValueError: Test error` being the error raised to Luau.
    Raising a RawError however will lead to `Test error` being the error raised to Luau.
    """
    def __new__(cls, message:builtins.str) -> RawError: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class String:
    r"""
    A handle to a Lua-owned string value.
    
    Can be created using Lua.create_string()
    
    Note: using a string once the Lua state has been closed will result in a exception.
    """
    @property
    def pointer(self) -> builtins.int:
        r"""
        Returns the pointer to the Lua string value.
        
        This pointer cannot be converted back to a Lua string
        and is only useful for hashing and debugging.
        """
    def as_bytes(self) -> typing.Any:
        r"""
        Returns the string value as a bytes
        """
    def as_bytes_with_nul(self) -> typing.Any:
        r"""
        Returns the string value as a bytes with the null terminator
        """
    def __len__(self) -> builtins.int:
        r"""
        Returns the string's length in bytes.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __eq__(self, other:typing.Any) -> builtins.bool: ...

class Table:
    ...

class Thread:
    ...

class UserData:
    @property
    def pointer(self) -> builtins.int:
        r"""
        Returns the pointer/address of the userdata.
        """
    def data(self) -> typing.Any:
        r"""
        Returns the underlying associated data of the userdata.
        
        Errors if the userdata does not contain associated data (did not originate from Python)
        """
    def metatable(self) -> Table:
        r"""
        Returns the underlying metatable of the userdata.
        """
    def __repr__(self) -> builtins.str: ...
    def __eq__(self, other:UserData) -> builtins.bool: ...

class Vector:
    @property
    def x(self) -> builtins.float: ...
    @property
    def y(self) -> builtins.float: ...
    @property
    def z(self) -> builtins.float: ...
    def __new__(cls, x:builtins.float, y:builtins.float, z:builtins.float) -> Vector:
        r"""
        Constructs a new vector
        """
    @staticmethod
    def zero() -> Vector: ...
    def __repr__(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...

class LuaType(Enum):
    Boolean = ...
    LightUserData = ...
    Number = ...
    Vector = ...
    String = ...
    Function = ...
    Thread = ...
    Buffer = ...

class VmState(Enum):
    Continue = ...
    Yield = ...

